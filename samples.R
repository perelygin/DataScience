#Чем больше вы знаете разнообразных функций для работы с векторами, тем больше существует вариантов для решения простых задач. 
#Пусть имеется вектор x произвольного типа. Какая конструкция может быть использована, чтобы получить содержимое вектора x без 
#каждого седьмого элемента?
#P.S. Давайте предполагать, что понятие "каждый седьмой" имеет смысл, то есть элементов в векторе хотя бы семь.

x[-(seq(7, length(x), by = 7))]

x[1:length(x) %% 7 != 0]

x[c(rep(T, 6), F)]

x[1:length(x) %% 7 > 0]

x[-(1:floor(length(x)/7) * 7)]

#обращение по индексу
x<-c(1, 23, 5, 19, 15, 13, 5)
letters[x]
#[1] "a" "w" "e" "s" "o" "m" "e"
#распечатать все числа от одного до ста, заменив каждое третье чсло на "fiz",  каждое пятое на bazz,  а если число делится и на 3 и на 5
# т.е.  на 15, то напечать "fizz bass"
# типовое решение через for
fiz_bass <- function(x) {
  for(i in 1:100){
    if(i %% 15 == 0){
      x[i] <- "fiz bazz"
    } else if(i %% 5 == 0){
      x[i] <- "bazz"
    }else if(i %% 3 == 0){
      x[i]<-"fiz"
    } else{
      x[i] <- i
    }
  }
  print(x)
}  
#y<-character(100)
# y<- fiz_bass(y)
#решение с использованием векторного индексирования
x<- 1:100
z<- 1:100
x %% 5 #вектор содержит остаттки от деления на 5
x %% 5 ==0 #вектор содержит логические значения  FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE .....
z[x %% 5 ==0]<-"bazz"  ##заменяем в векторе z значения с индексом "1"    "2"    "3"    "4"    "bazz" "6"    "7"    "8"    "9"    "bazz" "11" 
z[x %% 3 ==0]<-"fiz"
z[x %% 15 ==0]<-"fiz bazz"

#проверить совпадение векторов
all(z==y)

#получение одинковой случайной последвательности
set.seed(42)
x<-sample(1:100,50)
#найти два соседних числа,  которые различаются на максимальную величину
#1 создать вектор,  который будет содержать все попарные разницы-  вторе минус первое,  третье минус второе и т.д. 
#x[-1] вернет вектор без первого элемента,  x[-length(x)]  - без последнего
#x[-1]-x[-length(x)] - разница между каждым элементом второго и первого массива 
#k <- which.max(abs(x[-1]-x[-length(x)]))  - получаем индекс максимального отклония(по модулю)
#x[c(k,k+1)] - сначала получили вектор индексов,  потом взяли элементы исходного массива по индексам

x<-sample(1:100,50, replace = TRUE)
#случайная последовательность с повторением
which(x== min(x)) #

#Пусть вектор называется нестрого возрастающим, если каждый следующий элемент в нём не меньше, чем предыдущий. 
#Точно так же, вектор назовём нестрого убывающим, если каждый следующий элемент в нём не больше, чем предыдущий. 
#Напишите функцию, которая принимает один аргумент (числовой вектор) и возвращает TRUE, если вектор обладает свойством 
#нестрогой монотонности, то есть является либо несторого возрастающим, либо нестрого убывающим. 
#В противном случае функция возвращает FALSE.
#Пример. x=c(0, 0, 3, 4, 4, 8) нестрого возрастает, возвращаем TRUE. y=c(3:0, 1) был бы нестрого убывающим, если бы не последняя 
#единица, поэтому возвращаем FALSE.
#Подсказки: 
# "Не меньше" = "больше либо равно".
#обратите внимание на постоянный вектор, например rep(0, 10). Является ли он нестрого возрастающим? А нестрого убывающим?


is_monotone <- function(x) {
  y<-x[-1]
  z<-x[-length(x)]
  u<-(y-z)>=0
  rez1 <- which(u == FALSE)
  w<-(y-z)<=0
  rez2 <- which(w == FALSE)
  if(length(rez1)==0 | length(rez2)==0){
    return(TRUE)
  }else{
    return(FALSE)
  }
}


combin_count <- function(n, k, with_repretitions = FALSE) {
  if(with_repretitions == TRUE){
    return(factorial(n+k-1)/(factorial(k)*factorial(n-1)))
  }else{
    return(factorial(n)/(factorial(k)*factorial(n-k)))   
  }
}


#работа с матрицами
matr <-function(m, n) {
  mat <- matrix(0, m, n)
            mat[m, n] <-55
  print(mat[n,m]) 
  
}  

#работа с матрицамиc
#Предположим, что у нас есть целочисленный вектор v и число n. Наша задача — найти позицию элемента в векторе, 
#который ближе всего к числу n. При этом если таких элементов несколько, необходимо указать все позиции.
#Напишите функцию, которая принимает на вход вектор и число и возвращает вектор индексов, отвечающих указанному условию. 
#Индексы должны быть выстроены по возрастанию.
#Пример. Пусть v <- c(5, 2, 7, 7, 7, 2, 0, 0) и n=1. Ответом будет вектор
#2 6 7 8
#Подсказки: 
#"ближе всего" означает минимальную разницу между числами;
#не забудьте про модуль!
find_closest <-function(v, n) {
  #print(v)
  b<-abs(v-n)
  #print(b)
  m<-which(b == min(b))
  #print(m)
  return(sort(m))
} 


#нужно взять две матрицы и сложить их таким ор\бразом,  что верхний левый угло - это матрица m1, правый нижний - это m2, а остальные 
# элементы - это некий элемент
bind_diag<-function(m1,m2,fill){
  #заполним матрицу элементом fill
  m3<-matrix(fill,nrow = nrow(m1)+nrow(m2),ncol = ncol(m1)+ncol(m2))
  m3[1:nrow(m1), 1:ncol(m1)]<-m1
  m3[nrow(m1)+1:nrow(m2),ncol(m1)+1:ncol(m2)]<-m2
  print(m3)
}

m1<-matrix(1:12,nrow = 3)
m2<-matrix(10:15,ncol = 3)


build_ziggurat <- function(n) {
#создаем четвертинку матрицы
 x<-matrix(1,n,n) 
 c<-1:n
 for(i in 0:(n-1)){
   x[i+1,1:(n-i)]<-c[1:(n-i)]  
   if(n-i+1 <= n){
     x[i+1,(n-i+1):n]<- n-i
   }
 }
 if(n<=1){
   #print(x)
   return(x)
 }else{
   #print(x)
   #создаем итоговую матрицу- нижнюю половину
   m1<-matrix(0,nrow = nrow(x),ncol = ncol(x)*2-1)
   m1[1:nrow(x),1:ncol(x)]<-x
   m1[1:nrow(x),(ncol(x)+1):ncol(m1)]<-x[1:nrow(x),(ncol(x)-1):1]
   #print(m1)
   #теперь верхнюю половину
   m2<-matrix(0,nrow = nrow(m1)*2-1,ncol = ncol(m1))
   m2[nrow(m1):nrow(m2),1:ncol(m2)]<-m1
   m2[(nrow(m1)-1):1,1:nrow(m2)]<-m1[2:nrow(m1),1:ncol(m1)]
   #print(m2)  
   return(m2)
 }
 
}
