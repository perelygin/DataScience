#Чем больше вы знаете разнообразных функций для работы с векторами, тем больше существует вариантов для решения простых задач. 
#Пусть имеется вектор x произвольного типа. Какая конструкция может быть использована, чтобы получить содержимое вектора x без 
#каждого седьмого элемента?
#P.S. Давайте предполагать, что понятие "каждый седьмой" имеет смысл, то есть элементов в векторе хотя бы семь.

x[-(seq(7, length(x), by = 7))]

x[1:length(x) %% 7 != 0]

x[c(rep(T, 6), F)]

x[1:length(x) %% 7 > 0]

x[-(1:floor(length(x)/7) * 7)]

#обращение по индексу
x<-c(1, 23, 5, 19, 15, 13, 5)
letters[x]
#[1] "a" "w" "e" "s" "o" "m" "e"
#распечатать все числа от одного до ста, заменив каждое третье чсло на "fiz",  каждое пятое на bazz,  а если число делится и на 3 и на 5
# т.е.  на 15, то напечать "fizz bass"
# типовое решение через for
fiz_bass <- function(x) {
  for(i in 1:100){
    if(i %% 15 == 0){
      x[i] <- "fiz bazz"
    } else if(i %% 5 == 0){
      x[i] <- "bazz"
    }else if(i %% 3 == 0){
      x[i]<-"fiz"
    } else{
      x[i] <- i
    }
  }
  print(x)
}  
#y<-character(100)
# y<- fiz_bass(y)
#решение с использованием векторного индексирования
x<- 1:100
z<- 1:100
x %% 5 #вектор содержит остаттки от деления на 5
x %% 5 ==0 #вектор содержит логические значения  FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE .....
z[x %% 5 ==0]<-"bazz"  ##заменяем в векторе z значения с индексом "1"    "2"    "3"    "4"    "bazz" "6"    "7"    "8"    "9"    "bazz" "11" 
z[x %% 3 ==0]<-"fiz"
z[x %% 15 ==0]<-"fiz bazz"

#проверить совпадение векторов
all(z==y)

#получение одинковой случайной последвательности
set.seed(42)
x<-sample(1:100,50)
#найти два соседних числа,  которые различаются на максимальную величину
#1 создать вектор,  который будет содержать все попарные разницы-  вторе минус первое,  третье минус второе и т.д. 
#x[-1] вернет вектор без первого элемента,  x[-length(x)]  - без последнего
#x[-1]-x[-length(x)] - разница между каждым элементом второго и первого массива 
#k <- which.max(abs(x[-1]-x[-length(x)]))  - получаем индекс максимального отклония(по модулю)
#x[c(k,k+1)] - сначала получили вектор индексов,  потом взяли элементы исходного массива по индексам

x<-sample(1:100,50, replace = TRUE)
#случайная последовательность с повторением
which(x== min(x)) #

#Пусть вектор называется нестрого возрастающим, если каждый следующий элемент в нём не меньше, чем предыдущий. 
#Точно так же, вектор назовём нестрого убывающим, если каждый следующий элемент в нём не больше, чем предыдущий. 
#Напишите функцию, которая принимает один аргумент (числовой вектор) и возвращает TRUE, если вектор обладает свойством 
#нестрогой монотонности, то есть является либо несторого возрастающим, либо нестрого убывающим. 
#В противном случае функция возвращает FALSE.
#Пример. x=c(0, 0, 3, 4, 4, 8) нестрого возрастает, возвращаем TRUE. y=c(3:0, 1) был бы нестрого убывающим, если бы не последняя 
#единица, поэтому возвращаем FALSE.
#Подсказки: 
# "Не меньше" = "больше либо равно".
#обратите внимание на постоянный вектор, например rep(0, 10). Является ли он нестрого возрастающим? А нестрого убывающим?


is_monotone <- function(x) {
  y<-x[-1]
  z<-x[-length(x)]
  u<-(y-z)>=0
  rez1 <- which(u == FALSE)
  w<-(y-z)<=0
  rez2 <- which(w == FALSE)
  if(length(rez1)==0 | length(rez2)==0){
    return(TRUE)
  }else{
    return(FALSE)
  }
}




combin_count <- function(n, k, with_repretitions = FALSE) {
  if(with_repretitions == TRUE){
    return(factorial(n+k-1)/(factorial(k)*factorial(n-1)))
  }else{
    return(factorial(n)/(factorial(k)*factorial(n-k)))   
  }
}


#работа с матрицами
matr <-function(m, n) {
  mat <- matrix(0, m, n)
            mat[m, n] <-55
  print(mat[n,m]) 
  
}  

#работа с матрицамиc
#Предположим, что у нас есть целочисленный вектор v и число n. Наша задача — найти позицию элемента в векторе, 
#который ближе всего к числу n. При этом если таких элементов несколько, необходимо указать все позиции.
#Напишите функцию, которая принимает на вход вектор и число и возвращает вектор индексов, отвечающих указанному условию. 
#Индексы должны быть выстроены по возрастанию.
#Пример. Пусть v <- c(5, 2, 7, 7, 7, 2, 0, 0) и n=1. Ответом будет вектор
#2 6 7 8
#Подсказки: 
#"ближе всего" означает минимальную разницу между числами;
#не забудьте про модуль!
find_closest <-function(v, n) {
  #print(v)
  b<-abs(v-n)
  #print(b)
  m<-which(b == min(b))
  #print(m)
  return(sort(m))
} 


#нужно взять две матрицы и сложить их таким ор\бразом,  что верхний левый угло - это матрица m1, правый нижний - это m2, а остальные 
# элементы - это некий элемент
bind_diag<-function(m1,m2,fill){
  #заполним матрицу элементом fill
  m3<-matrix(fill,nrow = nrow(m1)+nrow(m2),ncol = ncol(m1)+ncol(m2))
  m3[1:nrow(m1), 1:ncol(m1)]<-m1
  m3[nrow(m1)+1:nrow(m2),ncol(m1)+1:ncol(m2)]<-m2
  print(m3)
}

m1<-matrix(1:12,nrow = 3)
m2<-matrix(10:15,ncol = 3)


build_ziggurat <- function(n) {
#создаем четвертинку матрицы
 x<-matrix(1,n,n) 
 c<-1:n
 for(i in 0:(n-1)){
   x[i+1,1:(n-i)]<-c[1:(n-i)]  
   if(n-i+1 <= n){
     x[i+1,(n-i+1):n]<- n-i
   }
 }
 if(n<=1){
   #print(x)
   return(x)
 }else{
   #print(x)
   #создаем итоговую матрицу- нижнюю половину
   m1<-matrix(0,nrow = nrow(x),ncol = ncol(x)*2-1)
   m1[1:nrow(x),1:ncol(x)]<-x
   m1[1:nrow(x),(ncol(x)+1):ncol(m1)]<-x[1:nrow(x),(ncol(x)-1):1]
   #print(m1)
   #теперь верхнюю половину
   m2<-matrix(0,nrow = nrow(m1)*2-1,ncol = ncol(m1))
   m2[nrow(m1):nrow(m2),1:ncol(m2)]<-m1
   m2[(nrow(m1)-1):1,1:nrow(m2)]<-m1[2:nrow(m1),1:ncol(m1)]
   #print(m2)  
   return(m2)
 }
 
}

#Пусть x -- целочисленный вектор. Напишите функцию, которая вернёт матрицу из двух строк. 
#В первой строке перечислите все различные элементы вектора, упорядоченные по возрастанию. Во второй строке укажите частоты 
#(количество повторов) этих элементов.
#Пример. Пусть x <- c(5, 2, 7, 7, 7, 2, 0, 0). Тогда функция должна вернуть матрицу 2х4 с элементами
#0 2 5 7
#2 2 1 3
count_elements <- function(x) {
  y<-rle(sort(x))
  m1<-matrix(0, nrow = 2, ncol = length(y[["lengths"]]))
  m1[1,1:length(y[["values"]])]<-y[["values"]]
  m1[2,1:length(y[["lengths"]])]<-y[["lengths"]]
  return(m1)
}

#
#Парижане бунтуют! По слухам, Бастилия плохо охраняется, а её арсеналы полны пороха и мушкетов.
#Пришло время решительных действий. Наши агенты смогли подсчитать количество солдат в патрулях в каждой из восьми башен крепости. Вот эти данные:
#Составьте короткий отчёт: какая из башен менее всего защищена, сколько в ней солдат, и сколько всего солдат в Бастилии? Свобода, равенство, братство!
#P.S. Формат ответа: tower_name, XX, YY�: полное название башни как в списке (без кавычек) и два числа. В качестве разделителя -- запятая и пробел. 
  
  
set.seed(1789)
bastille <- list(
  "La Chapelle Tower" = rbinom(5, 10, 1/2), 
  "Tresor Tower" = rbinom(8, 12, 1/4), 
  "Comte Tower" = rbinom(14, 3, 1/5) + 1,
  "Baziniere Tower" = rbinom(8, 4, 4/5), 
  "Bertaudiere Tower" = rbinom(4, 8, 2/3),
  "Liberte Tower" = rbinom(1, 100, 0.1), 
  "Puits Tower" = rbinom(5, 5, 0.7),
  "Coin Tower" = rbinom(3, 16, 0.4)
)
y<-sapply(bastille, sum)
sum_all<-sum(y)
z<-which.min(y)
st<-cat(names(z),bastille[[z]],sum_all,sep = ', ')




#Пусть целочисленная матрица m содержит некоторое количество нулей, которое мы хотим заменить на пропущенные значения. Какая из конструкций произведёт такую замену?
#P.S. Для того, чтобы, наоборот, заменить NA, нужно использовать специальную функцию is.na: сравнения вида m == NA всегда возвращают NA.


m<-matrix(1, nrow = 5, ncol = 5)
m[3:4,2:3]<-0

m[m == 0] <- NA
m <- apply(m, 1:2, function(k) if (!k) NA else k)
for (i in 1:nrow(m)) {for (j in 1:ncol(m)) {if (m[i, j] == 0) m[i, j] <- NA}} # omg who wrote this? 


#Вы решили, что самое главное для вас -- это возможность учиться новому (learning). Возьмите 5 топовых департаментов по этому 
#показателю. Из этого набора вам более всего подойдёт тот департамент, который имеет наибольшую сумму баллов по трём показателям: 
#реакция на жалобы работников (complaints), надбавки в зависимости от результатов работы (raises) и возможность продвижения 
#(advance).

#добавили колонку
attitude$new.col <- attitude$complaints+attitude$raises+attitude$advance
#отслортировали по lerning и взяли первые 5
m1<-attitude[order(attitude$learning,decreasing = T),][1:5,]
#выбираем 1е пять колонок
#теперь сортируем по новой колонке
m1[order(m1$new.col,decreasing = T),]
#получаем номер первой строки
as.numeric(rownames(m1[order(m1$new.col,decreasing = T),]))[1]



#Какими из нижеуказанных способов можно выбрать только те строки, которые соответствуют департаментам с рейтингом (rating) 
#ниже пятидесяти, при этом сохранив все столбцы, кроме rating?

attitude[attitude$rating < 50, names(attitude) != "rating"]
subset(sel = -rating, sub = rating < 50, attitude)
subset(attitude, rating < 50, -rating)


##загрузка файла
avian<-read.csv("~/Downloads/avianHabitat.csv")
#проверка
str(avian)
head(avian)
summary(avian)
#поиск пропущеных значений
any(!complete.cases(avian))
#есть ли какое-нибудь значение меньше нуля?
any(avian$PDB<0)
#функция проверки 
check_procent_range <- function(x)  {
  any(x < 0 | x>100)
}
#трансформация переменных
names(avian)  #Перечень переменных
cov_aver<-names(avian)[-(1:4)][c(T,F)] #выбираем каждый второй элемент отбросив первые 4
avian$total <- rowSums(avian[,cov_aver]) #создаем новую переменную  

rm(list = ls())
avian<-read.csv("~/Downloads/avianHabitat.csv")
avian1<-read.csv("~/Downloads/avianHabitat2.csv",sep = ";")
avian1$Observer<-"CL"
#объединяем два датафрейма
names(avian1)
av<-rbind(avian,avian1)
av[av$Observer == "CL",]# проверка загруженных

names(av)
cov_aver<-names(av)[-(1:4)][c(T,F)] #выбираем каждый второй элемент отбросив первые 4
av$total <- rowSums(av[,cov_aver])








#Растительность Аляски, как мы уже знаем, достаточно скудна. Исследователям интересно, какие выдающиеся экземпляры растений удалось обнаружить? На массиве avianHabitat найдите максимальные высоты по каждому виду растений и отсортируйте эти виды по убыванию, от самого высокого к самому низкому.
#
#Подсказки:
#вас будут интересовать только данные переменных, отвечающих за высоты растений. Такие переменные заканчиваются на Ht;
#индексация с двойными скобками похожа на индексацию по значку доллара $, но есть одна тонкость: сравните результат 
#
#my_var <- "Site"; avian$my_var
#my_var <- "Site"; avian[[my_var]]
#данные Карлоша можно не учитывать: он вылетел из аспирантуры.

avian<-read.csv("~/Downloads/avianHabitat.csv")
cov_aver<-names(avian)[-(1:5)][c(T,F)]
m<-1:length(cov_aver)
df<-avian[cov_aver]


